<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
  <link rel="stylesheet" type="text/css" href="css/bootstrap.css">
  <link rel="stylesheet" type="text/css" href="css/prettify.css">
  <link rel="stylesheet" type="text/css" href="css/adamdoc.css">

 
  <script type="text/javascript" src="js/prettify/prettify.js"></script>

  <!-- <script src="js/prettify/run_prettify.js"></script> -->


</head>
<body>

  <div class="container">
    <div class="navbar navbar-inverse" style="margin-top:10px">
      <div class="navbar-inner">
        <ul class="nav">
          <li><a href="#main">Main</a></li>
	  <li><a href="#math">Math</a></li>
    <li><a href="#broker">Broker</a></li>

          <li><a href="#store">Store</a></li>
        </ul>
      </div>
    </div>

   <div style="text-align:center;padding-top:20px;padding-bottom:20px">
     <h1>Adam Strategy Developement Guide</h1>
     <h5>(c) 2013, Clément Gamé.</h5>
  </div>

  <h3>1.Introduction</h3>
  This paper describes how to develop strategies code for the Adam trading bot.<br>
  In the following chapters we will describe how the strategies engine actually works, what are the functions and structures 
  that can be used to create trading strategies, and finally how to take advantage of all of these functions.<br><br>

  <b>Note:</b> In Adam, Trading strategies are written in C language, so this documentation takes as granted that the reader already knows how to write code in C ( even though the language complexity is most of the time heavilly hidden behind a large set of macro definitions ).

  <h3>2.Trading Strategies Engine</h3>
 
  The core of the Adam Software is called TSE, For Trading Strategies Engine. This is the part which
  executes the strategies developped by the user, and takes actions accordingly. The whole strategy code is evaluated every second on all the indices, so when you think and design your code, allways keep this in mind: <b>Your strategies functions are executed like some loops, at every second !</b>  


  <h3>3.Evaluation Functions</h3>

  Evaluation functions are were you must put your strategy code: Each index you want to work with has its own evaluation function inside the strategy, and must be named and prototyped according to the following pattern:

  <pre style="padding-bottom:0px;height:28px;margin-top:10px">
    void* &lt;INDEX_NAME&gt;_EVAL() { }
  </pre> 

  <h4>3.1.Functions Names Mapping</h4>
  You now may ask yourself how the Trading Strategies Engine can know which evaluation function goes with which stock or index, 
  and in fact this is quite simple: the evaluation function names <b>MUST</b> be mapped to the indices defined in the adam configuration file (/etc/adam/adam.conf in Unix). For instance, let's assume that you have inside your configuration file the following line:

  <pre style="padding-bottom:0px;height:28px;margin-top:10px">
    indice = DOW_MINI 1 IX.D.DOW.IFE.IP point
  </pre>
  Then, if you want to create a strategy function that will evaluate the price of DOW_MINI, you'll have to create a function which will be:
  <pre class="prettyprint linenums" style="margin-top:10px">
    void* DOW_MINI_EVAL() {}  
  </pre>

  <h4>3.2.Decorator</h4>
  In order to hide the complexity of the language, the evaluation functions get decorated before being actually compiled.
  You must know as a notice that in fact, the real signature of an evaluation function is:

  <pre class="prettyprint linenums" style="margin-top:10px">
    void* <INDEX_NAME>_EVAL(uint32_t t, 
                float v,iarray* tstamps, 
                farray* values,
                char* ans,
                char* log_s,
                store* s,
                struct evmio_array* evmio_a) {}  
  </pre>

  Some of these parameters will be explained in the next chapters of this document, the others being not really relevant for strategies developpers.

  Also please note that if you really want to , you can define evaluation functions with this signature, and that it will work as usual.

  <h3>4.Hello World</h3>
  In this section we will create a basic code that will display "Hello World" every second.<br>

  <pre class="prettyprint linenums" style="margin-top:10px">
    void* DOW_MINI_EVAL() {                                                  
      printf("Hello World!\n");
    }
  </pre>

  explaination: We simply created a new evaluation function (related to the Dow Jones) , called
  <b>DOW_MINI_EVAL</b>.<br>
  Then each time this function is executed (every second), 
  it will print "Hello World!" on the standard output ( because of the printf() function ). 


 <h3>5.A more practical Example</h3>

 In this part we will create something a bit more useful, a really simple strategy that will print "Hoody!" if the indice/stock price reaches a certain value:

 <pre class="prettyprint linenums" style="margin-top:10px">
    void* DOW_MINI_EVAL() {
      if ( sup(15000) ) {
        printf("Hoody!");
      }                                                
    }
  </pre>

 <h3>6.Types and Structures</h3>

Aside from the usual types that you can find in C (int,char,float..) , we created a set of new types and 
structures in order to facilitate the manipulation of stock/index prices and timestamped events.

<h4>6.1.farray</h4>

This new structure introduced by Adam is probably the most important of all, because it's the main kind of objects that you will have to manipulate while creating your trading strategies. farray is a struct that is in fact an array of float numbers,
with a size and capacity indicator.<br><br>

The structure is the following:

<pre class="prettyprint linenums" style="margin-top:10px">

  typedef struct farray {

  float* values;
  int size;
  int msize;

} farray;

</pre>

As you can see, values is a an array of floats.<br>
size represents the number of elements inside the floats array, and msize represents the (current) capacity of the array. 


<h4>6.2.iarray</h4>

iarray is the same kind of structure than farray, but for integers.

The structure of an iarray is:

<pre class="prettyprint linenums" style="margin-top:10px">

  typedef struct iarray {

  uint32_t* values;
  int size;
  int msize;

} iarray;

</pre>


 <h3>7.Variables of Interest</h3>

 As we've seen earlier, evaluation functions are decorated and their real signature is in fact much more complex that it seems.


 <h3 id="main">8.General Functions</h3>

 the TSE comes with a tiny set of core functions that will help you to elaborate your strategies.

 <h4>Functions List</h4>

 <code><a href="#inf">inf()</a></code>&nbsp;&nbsp;<code><a href="#infeq">infeq()</a></code>&nbsp;&nbsp;
 <code><a href="#sup">sup()</a></code>&nbsp;&nbsp;<code><a href="#supeq">supeq()</a></code>&nbsp;&nbsp;
 <code><a href="#eq">eq()</a></code>&nbsp;&nbsp;  <code><a href="#sample">sample()</a></code>&nbsp;&nbsp;

 <code><a href="#log">log()</a></code>&nbsp;&nbsp;<br>
 <code><a href="#counter">counter()</a></code>&nbsp;&nbsp;<code><a href="#is_time">is_time()</a></code>&nbsp;&nbsp;

 <h4>Functions</h4>

<div class="fct" id="inf" style="margin-top:15px">
<h4><code class="fct_code">inf(float value)</code> {int}</h4>
Tests if the current stock/index value (v) is strictly inferior to the value passed as argument.

<h5>@Parameters :</h5>

<code>float value</code>: the value to compare v with<br>

<h5>@Returns :</h5>
  1 if v is strictly inferior to value, 0 otherwise.
</div>

<div class="fct" id="infeq" style="margin-top:15px">
<h4><code class="fct_code">infeq(float value)</code> {int}</h4>
Tests if the current stock/index value (v) is inferior or equal to the value passed as argument.

<h5>@Parameters :</h5>

<code>float value</code>: the value to compare v with<br>

<h5>@Returns :</h5>
  1 if v is inferior or equal to value, 0 otherwise.
</div>


<div class="fct" id="sup" style="margin-top:15px">
<h4><code class="fct_code">sup(float value)</code> {int}</h4>
Tests if the current stock/index value (v) is strictly superior than the value passed as argument.

<h5>@Parameters :</h5>

<code>float value</code>: the value to compare v with<br>

<h5>@Returns :</h5>
  1 if v is strictly superior than value, 0 otherwise.
</div>

<div class="fct" id="supeq" style="margin-top:15px">
<h4><code class="fct_code">supeq(float value)</code> {int}</h4>
Tests if the current stock/index value (v) is superior or equal to the value passed as argument.

<h5>@Parameters :</h5>

<code>float value</code>: the value to compare v with<br>

<h5>@Returns :</h5>
  1 if v is superior or equal to value, 0 otherwise.
</div>

<div class="fct" id="eq" style="margin-top:15px">
<h4><code class="fct_code">eq(float value)</code> {int}</h4>
Tests if the current stock/index value (v) is equal to the value passed as argument.

<h5>@Parameters :</h5>

<code>float value</code>: the value to compare v with<br>

<h5>@Returns :</h5>
  1 if v is equal to value, 0 otherwise.
</div>


<div class="fct" id="sample" style="margin-top:15px">
<h4><code class="fct_code">sample(int t0,int t1)</code> {farray*}</h4>
sample() is a critical and very important function for building your strategies, because it allows
to extract a sample of data from the index values array, given time parameters.

<h5>@Parameters :</h5>

<code>int t0</code>: start time of the sample you want to extract. If t0 is > 0, it is considered as an Unix timestamp. If t0 is &lt; 0, it is then considered as a time offset from current time <br>
<code>int t1</code>: end time of the sample you want to extract. If t1 is > 0, it is considered as an Unix timestamp. If t1 is &lt; 0, it is then considered as a time offset from current time <br>

<h5>@Returns :</h5>
  The sampled floats array.
</div>


<div class="fct" id="log" style="margin-top:15px">
<h4><code class="fct_code">log(char* ct)</code> {void*}</h4>
Puts a log entry inside the adam log file.

<h5>@Parameters :</h5>
<code>char* ct</code>: the string content to put inside the log file<br>

</div>





 <h3 id="math">9.Math Functions</h3>
 
 Of course when we speak of writing trading strategies, we need a set of finance-oriented, mathematical functions that will help make the good decision about positions taking. In this context, the Adam TSE comes obviously with a full set of these functions.<br><br>

 <h4>Functions List</h4>

 <code><a href="#min">min()</a></code>&nbsp;&nbsp;<code><a href="#max">max()</a></code>&nbsp;&nbsp;
 <code><a href="#avg">avg()</a></code>&nbsp;&nbsp;<code><a href="#variance">variance()</a></code>&nbsp;&nbsp;
 <code><a href="#covariance">covariance()</a></code>&nbsp;&nbsp;<code><a href="#deviation">stdDeviation()</a>
</code>&nbsp;&nbsp;<code><a href="#pdelta">percentDelta()</a></code>&nbsp;&nbsp;<br><br>
 <code><a href="#cmavg">cmavg()</a></code>&nbsp;&nbsp;<code><a href="#lreg">lreg()</a></code>&nbsp;&nbsp;
 <code><a href="#lreg_coefs">lreg_coefs()</a></code>&nbsp;&nbsp;
  <code><a href="#above">above()</a></code>&nbsp;&nbsp;<code><a href="#below">below()</a></code>&nbsp;&nbsp;


 <h4>Functions</h4>

<div class="fct" id="min" style="margin-top:15px">
<h4><code class="fct_code">min(farray* f)</code> {float}</h4>
 Returns the minimum value found inside the floats array passed as parameter.

<h5>@Parameters :</h5>

<code>farray* f</code>: floats array pointer for which you want to get the min value.<br>

<h5>@Returns :</h5>
The minimum value inside the float array passed as argument.

</div>

<div class="fct" id="max">
<h4><code class="fct_code">max(farray* f)</code> {float}</h4>
 Returns the maximum value found inside the floats array pointer passed as parameter.

 <h5>@Parameters :</h5>

 <code>farray* f</code>: floats array pointer for which you want to get the max value.<br>

<h5>@Returns :</h5>
The maximum value inside the float array passed as argument.


</div>

<div class="fct">
 <h4><code class="fct_code" id="avg">avg(farray* f)</code> {float}</h4>
 This function computes the average value of the floats array pointer passed as argument. Returns the computed average (float).

 <h5>@Parameters :</h5>
 <code>farray* f</code>: floats array pointer for which you want to compute average.<br>

 <h5>@Returns :</h5>
 Average of the float array passed as argument.

</div>

<div class="fct" id="variance">
 <h4><code class="fct_code">variance(farray* f,uint8_t sample)</code> {float}</h4>
 Computes the variance of the floats array pointer passed as argument.
 <h5>@Parameters :</h5>

 <code>farray* f</code>: floats array pointer for which you want to compute variance.<br>
 <code>uint8_t sample</code>: tells if you want variance on sample or not (if sample=0)<br>

<h5>@Returns :</h5>
Variance of the float array passed as argument.

</div>


<div class="fct" id="covariance">
 <h4><code class="fct_code">covariance(farray* f1,farray* f2)</code> {float}</h4>
 computes the covariance between two float arrays, can be useful to make correlations 
 between prices, even when applying time shifts. 

 <h5>@Parameters :</h5>

 <code>farray* f1</code>: first floats array pointer<br>
 <code>farray* f2</code>: second floats array pointer<br>

<h5>@Returns :</h5>
  Covariance between values in f1 and values in f2.
</div>

<div class="fct" id="deviation">
 <h4><code class="fct_code">stdDeviation(farray* f)</code> {float}</h4>
 Calculates the standard deviation of the float values inside f.
 <h5>@Parameters :</h5>

 <code>farray* f</code>: floats array pointer for which you want to compute standard deviation.<br>

<h5>@Returns :</h5>
Standard deviation of the values inside farray* f.
</div>


<div class="fct" id="pdelta">
 <h4><code class="fct_code">percentDelta(farray* f)</code> {float}</h4>
 Calculates the variation in percent between the first and the last value of floats array f.
 <h5>@Parameters :</h5>

 <code>farray* f</code>: floats array pointer for which you want to compute percentage delta.<br>

<h5>@Returns :</h5>
 variation in percent between the first and the last value of floats array f.
</div>


<div class="fct" id="cmavg">
 <h4><code class="fct_code">cmavg(farray* f)</code> {farray*}</h4>
 Calculates the cumulative moving average for the float values inside array f. 
 <h5>@Parameters :</h5>

 <code>farray* f</code>: floats array pointer for which you want to compute the cumulative moving average.<br>

<h5>@Returns :</h5>
  an array of floats pointer (farray*) containing the cumulative moving average of f.
</div>


<div class="fct" id="lreg">
 <h4><code class="fct_code">lreg(farray* f)</code> {farray*}</h4>
 Calculates the linear regression for the float values inside array f.
 <h5>@Parameters :</h5>

 <code>farray* f</code>: floats array pointer for which you want to compute the linear regression.<br>

<h5>@Returns :</h5>
  an array of floats pointer (farray*) containing the linear regression of f.

<h5>Note about lreg()</h5>
As you probably know, linear regression is usually computed with 2 data sets. Here the point is that we're 
using time for x coordinates, and that's why you don't have to provide it.

</div>



<h3 id="broker">10.Broker Functions</h3>

If everything goes right, some actions will flow from your strategies and you'll want to take positions on the market.
That's where the broker functions come into use, they are a direct communication path beween the Trading Strategy Engine 
and the broker module.

<h4>Functions List</h4>

 <code><a href="#buy">buy()</a></code>&nbsp;&nbsp;<code><a href="#sell">sell()</a></code>&nbsp;&nbsp;
 <code><a href="#order">order()</a></code>

<h4>Functions</h4>

<div class="fct" id="buy">
 <h4><code class="fct_code">buy(char* index,int quantity,int stoploss,int limit)</code> {void*}</h4>
 Opens a buy (long) position on the specified index/stock.
 <h5>@Parameters :</h5>

 <code>char* index</code>:  <br>
 <code>int quantity</code>: Number of contracts you want to pass in the deal<br>
 <code>int stoploss</code>: Maximum number of points (or pips) you can accept to lose before automatically closing the postion.<br>
 <code>int limit</code>: Maximum points (or pips) gain before automatically closing the position.<br>

</div>

<div class="fct" id="sell">
 <h4><code class="fct_code">sell(char* index,int quantity,int stoploss,int limit)</code> {void*}</h4>
 Opens a sell (short) position on the specified index/stock.
 <h5>@Parameters :</h5>

 <code>char* index</code>: <br>
 <code>int quantity</code>: Number of contracts you want to pass in the deal<br>
 <code>int stoploss</code>: Maximum number of points (or pips) you can accept to lose before automatically closing the postion.<br>
 <code>int limit</code>: Maximum points (or pips) gain before automatically closing the position.<br>

</div>


<h3 id="store">11.The Store</h3> 

As you know at this point, each evaluation function gets executed once every second. In this context,
we may have to save the current state of some data, for reuse in the next iterations of the evaluations.
And this is exactly what the store is for: keeping data state beween different iterations of your evaluations.<br><br>

The store is mainly a data structure: An associative array of 256 32bit unsigned integer values, where each value is associated to a string, and where you can save almost anything (except long long integers and other 64bit-sized values).

Also, because this structure is shared, the store is a very good way to share 
data between your different evaluation functions and make them communicate with each other.<br><br>

Finally, note that you can store data which is much longer than 32bit, because you can of course put pointers to malloc'd memspace inside a store slot (just be very careful about segfaults, as usual in C)<br><br>

In order to make the use of the store inside your strategies ridiculously easy, the TSE provides convenient functions to manipulate this structure:

<h4>Functions List</h4>

<code><a href="#store_store">store()</a></code>&nbsp;&nbsp;<code><a href="#store_get">get()</a></code>&nbsp;&nbsp;
<code><a href="#store_exists">exists()</a></code>&nbsp;&nbsp;


<div class="fct" id="store_store">
 <h4><code class="fct_code">store(const char* name,uint32_t value)</code> {void*}</h4>
 Stores a value associated with its name, inside the store structure.
 <h5>@Parameters :</h5>

 <code>const char* name</code>: Associated Name choosen to store the value <br>
  <code>uint32_t value</code>: 32bit integer representation of the value that must be stored (use (uint32_t) casting )<br>

</div>


<div class="fct" id="store_get">
 <h4><code class="fct_code">get(const char* name,type)</code> {type}</h4>
  Retrieves the value associated with name, and casts it to type.
 <h5>@Parameters :</h5>
 <code>const char* name</code>: Associated Name choosen when the value was first stored<br>
 <code>type</code>: type for which you want to cast the value into (can be float,int,char*, or any other 32bit sized type)<br>

 <h5>@Returns :</h5>
 the associated value, casted with the choosen type.

</div>

<div class="fct" id="store_exists">
 <h4><code class="fct_code">exists(const char* name)</code> {int}</h4>
  Tests if a value associated with name exists in the store
 <h5>@Parameters :</h5>
 <code>const char* name</code>: Associated name to test<br>

 <h5>@Returns :</h5>
  1 if the value exists, else 0.
</div>

 
  </div>

 <script type="text/javascript">prettyPrint();</script>

</body>
